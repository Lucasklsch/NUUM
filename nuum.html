<!DOCTYPE html>
<html lang="pt">
<head>
  <meta charset="UTF-8">
  <title>Clone DOOM ASCII 3D – Níveis Procedurais</title>
  <style>
    body {
      background-color: black;
      color: white;
      font-family: monospace;
      margin: 0;
      text-align: center;
    }
    /* Container do jogo */
    #game-container {
      position: relative;
      display: inline-block;
      margin-top: 20px;
    }
    /* HUD: informações de vida, munição e arma atual */
    #hud {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 4;
      color: yellow;
      font-size: 18px;
      pointer-events: none;
    }
    /* Renderização ASCII */
    #screen {
      z-index: 1;
      white-space: pre;
      margin: 0;
      padding: 0;
    }
    /* Imagem da arma */
    #weapon {
      position: absolute;
      bottom: -25%;
      left: 50%;
      transform: translateX(-50%);
      z-index: 2;
      width: 300px;
      pointer-events: none;
    }
    /* Efeito de recuo ao disparar */
    #weapon.firing {
      transform: translateX(-50%) translateY(-10px);
      transition: transform 0.1s;
    }
    /* Imagem de impacto */
    #impact {
      position: absolute;
      display: none;
      z-index: 3;
      pointer-events: none;
      transform: translate(-50%, -50%);
      width: 50px;
    }
    /* Oculta os elementos de áudio */
    audio {
      display: none;
    }
  </style>
</head>
<body>
  <div id="game-container">
    <div id="hud"></div>
    <pre id="screen"></pre>
    <img id="weapon" src="weapon.png" alt="Arma">
    <img id="impact" src="impact.png" alt="Impacto">
    <audio id="pistolSound" src="pistol.wav"></audio>
    <audio id="shotgunSound" src="shotgun.wav"></audio>
    <audio id="bfgSound" src="bfg.wav"></audio>
    <audio id="walkSound" src="walk.wav" loop></audio>
  </div>

  <script>
    /////////////////////////////////
    // Geração Procedural do Mapa  //
    /////////////////////////////////
    function generateMap(width, height) {
      let map = [];
      for (let y = 0; y < height; y++) {
        let row = "";
        for (let x = 0; x < width; x++) {
          // Bordas sempre como parede
          if (y === 0 || y === height - 1 || x === 0 || x === width - 1) {
            row += "#";
          } else {
            // 30% de chance de ser parede, 70% chão
            row += (Math.random() < 0.3) ? "#" : ".";
          }
        }
        map.push(row);
      }
      return map;
    }

    // Função para obter uma posição aleatória que seja chão ('.')
    function getRandomFloor(map) {
      let x, y;
      do {
        x = Math.floor(Math.random() * map[0].length);
        y = Math.floor(Math.random() * map.length);
      } while (map[y][x] !== '.');
      return { x, y };
    }

    // Dimensões do mapa procedural
    const mapWidth = 16;
    const mapHeight = 16;
    let map = generateMap(mapWidth, mapHeight);
    console.log("Mapa Gerado:\n" + map.join("\n"));

    /////////////////////////////////
    // Configurações do Jogador    //
    /////////////////////////////////
    // Posiciona o jogador em um local seguro (piso)
    let playerPos = getRandomFloor(map);
    let playerX = playerPos.x + 0.5;
    let playerY = playerPos.y + 0.5;
    let playerA = 0;
    const FOV = Math.PI / 4;
    const depth = 16.0;
    // Dimensões da renderização ASCII
    const screenWidth = 120;
    const screenHeight = 40;
    let playerHealth = 100;
    let playerAmmo = 30;
    let gameOver = false;

    /////////////////////////////////
    // Sistema de Armas            //
    /////////////////////////////////
    let currentWeapon = "pistol";

    /////////////////////////////////
    // Inimigos, Balas e Pickups   //
    /////////////////////////////////
    // Gera inimigos em posições aleatórias (em chão)
    const enemyCount = 2;
    const enemies = [];
    for (let i = 0; i < enemyCount; i++) {
      let enemyPos = getRandomFloor(map);
      enemies.push({ x: enemyPos.x + 0.5, y: enemyPos.y + 0.5, alive: true, attackTimer: 0 });
    }

    const bullets = [];
    let canShoot = true;

    // Gera pickups aleatoriamente (tipos: "ammo" e "health")
    const pickups = [];
    const pickupTypes = ["ammo", "health"];
    for (let i = 0; i < 2; i++) {
      let pickupPos = getRandomFloor(map);
      pickups.push({ x: pickupPos.x + 0.5, y: pickupPos.y + 0.5, type: pickupTypes[i % pickupTypes.length], collected: false });
    }

    /////////////////////////////////
    // Controle de Teclado         //
    /////////////////////////////////
    const keys = {};
    window.addEventListener("keydown", (e) => {
      keys[e.key] = true;

      // Troca de arma: 1 = pistol, 2 = shotgun, 3 = bfg
      if (e.key === "1") {
        currentWeapon = "pistol";
        document.getElementById("weapon").src = "weapon.png";
      } else if (e.key === "2") {
        currentWeapon = "shotgun";
        document.getElementById("weapon").src = "shotgun.png";
      } else if (e.key === "3") {
        currentWeapon = "bfg";
        document.getElementById("weapon").src = "bfg.png";
      }

      // Reinicia o jogo se game over e "R" for pressionado
      if (gameOver && e.key.toLowerCase() === "r") {
        location.reload();
      }

      // Disparo: espaço dispara a arma atual
      if (e.key === " " && !gameOver) {
        if (canShoot && playerAmmo > 0) {
          shootCurrentWeapon();
          playerAmmo--;
          canShoot = false;
        }
      }
    });
    window.addEventListener("keyup", (e) => {
      keys[e.key] = false;
      if (e.key === " ") {
        canShoot = true;
      }
    });

    function shootCurrentWeapon() {
      if (currentWeapon === "pistol") {
        shootPistol();
      } else if (currentWeapon === "shotgun") {
        shootShotgun();
      } else if (currentWeapon === "bfg") {
        shootBFG();
      }
    }

    function shootPistol() {
      const pistolSound = document.getElementById("pistolSound");
      pistolSound.currentTime = 0;
      pistolSound.play();

      const weaponEl = document.getElementById('weapon');
      weaponEl.classList.add('firing');
      setTimeout(() => {
        weaponEl.classList.remove('firing');
      }, 100);

      bullets.push({
        x: playerX,
        y: playerY,
        dx: Math.sin(playerA),
        dy: Math.cos(playerA)
      });
    }

    function shootShotgun() {
      const shotgunSound = document.getElementById("shotgunSound");
      shotgunSound.currentTime = 0;
      shotgunSound.play();

      const weaponEl = document.getElementById('weapon');
      weaponEl.classList.add('firing');
      setTimeout(() => {
        weaponEl.classList.remove('firing');
      }, 100);

      const offsets = [-0.1, -0.05, 0, 0.05, 0.1];
      offsets.forEach(offset => {
        bullets.push({
          x: playerX,
          y: playerY,
          dx: Math.sin(playerA + offset),
          dy: Math.cos(playerA + offset)
        });
      });
    }

    function shootBFG() {
      const bfgSound = document.getElementById("bfgSound");
      bfgSound.currentTime = 0;
      bfgSound.play();

      const weaponEl = document.getElementById('weapon');
      weaponEl.classList.add('firing');
      setTimeout(() => {
        weaponEl.classList.remove('firing');
      }, 100);

      enemies.forEach(enemy => {
        if (!enemy.alive) return;
        let dx = enemy.x - playerX;
        let dy = enemy.y - playerY;
        let distance = Math.sqrt(dx * dx + dy * dy);
        let enemyAngle = Math.atan2(dx, dy) - playerA;
        if (Math.abs(enemyAngle) < 0.05 && distance < depth) {
          enemy.alive = false;
          showImpactAtEnemy(enemy);
        }
      });
    }

    function showImpactAtEnemy(enemy) {
      let dx = enemy.x - playerX;
      let dy = enemy.y - playerY;
      let distance = Math.sqrt(dx * dx + dy * dy);
      let enemyAngle = Math.atan2(dx, dy) - playerA;
      let enemyPos = (enemyAngle + FOV / 2.0) / FOV;
      if (enemyPos < 0 || enemyPos > 1) return;
      let enemyHeight = Math.floor(screenHeight / distance);
      let enemyWidth = enemyHeight;
      let enemyColumn = Math.floor(enemyPos * screenWidth) - Math.floor(enemyWidth / 2);
      let enemyRow = Math.floor((screenHeight / 2) - enemyHeight / 2);
      let screenEl = document.getElementById("screen");
      let rect = screenEl.getBoundingClientRect();
      let charWidth = rect.width / screenWidth;
      let charHeight = rect.height / screenHeight;
      let impactX = rect.left + (enemyColumn + enemyWidth / 2) * charWidth;
      let impactY = rect.top + (enemyRow + enemyHeight / 2) * charHeight;
      let impactEl = document.getElementById("impact");
      impactEl.style.left = impactX + "px";
      impactEl.style.top = impactY + "px";
      impactEl.style.display = "block";
      setTimeout(() => {
        impactEl.style.display = "none";
      }, 200);
    }

    function checkPickups() {
      for (let pickup of pickups) {
        if (pickup.collected) continue;
        let dx = pickup.x - playerX;
        let dy = pickup.y - playerY;
        let dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < 0.5) {
          pickup.collected = true;
          if (pickup.type === "ammo") {
            playerAmmo += 10;
          } else if (pickup.type === "health") {
            playerHealth = Math.min(playerHealth + 20, 100);
          }
        }
      }
    }

    function renderPickups(screenColumns) {
      for (let pickup of pickups) {
        if (pickup.collected) continue;
        let dx = pickup.x - playerX;
        let dy = pickup.y - playerY;
        let distance = Math.sqrt(dx * dx + dy * dy);
        let pickupAngle = Math.atan2(dx, dy) - playerA;
        let pickupPos = (pickupAngle + FOV / 2.0) / FOV;
        if (pickupPos < 0 || pickupPos > 1 || distance > depth) continue;
        let symbol = (pickup.type === "ammo") ? "A" : "H";
        let column = Math.floor(pickupPos * screenWidth);
        if (distance < zBuffer[column]) {
          let row = Math.floor(screenHeight / 2);
          screenColumns[column][row] = symbol;
        }
      }
    }

    /////////////////////////////////
    // Loop do Jogo (Game Loop)    //
    /////////////////////////////////
    let prevTime = Date.now();
    let zBuffer = new Array(screenWidth).fill(0);

    function gameLoop() {
      const currentTime = Date.now();
      const elapsedTime = (currentTime - prevTime) / 1000.0;
      prevTime = currentTime;

      if (!gameOver) {
        // Movimento do Jogador
        if (keys['w'] || keys['W']) {
          playerX += Math.sin(playerA) * 5 * elapsedTime;
          playerY += Math.cos(playerA) * 5 * elapsedTime;
          if (map[Math.floor(playerY)][Math.floor(playerX)] === '#') {
            playerX -= Math.sin(playerA) * 5 * elapsedTime;
            playerY -= Math.cos(playerA) * 5 * elapsedTime;
          }
        }
        if (keys['s'] || keys['S']) {
          playerX -= Math.sin(playerA) * 5 * elapsedTime;
          playerY -= Math.cos(playerA) * 5 * elapsedTime;
          if (map[Math.floor(playerY)][Math.floor(playerX)] === '#') {
            playerX += Math.sin(playerA) * 5 * elapsedTime;
            playerY += Math.cos(playerA) * 5 * elapsedTime;
          }
        }
        if (keys['a'] || keys['A']) {
          playerA -= 2 * elapsedTime;
        }
        if (keys['d'] || keys['D']) {
          playerA += 2 * elapsedTime;
        }

        const walkSound = document.getElementById("walkSound");
        if ((keys['w'] || keys['W'] || keys['s'] || keys['S']) && !gameOver) {
          if (walkSound.paused) {
            walkSound.play();
          }
        } else {
          if (!walkSound.paused) {
            walkSound.pause();
            walkSound.currentTime = 0;
          }
        }

        checkPickups();

        // Atualiza as balas
        for (let i = bullets.length - 1; i >= 0; i--) {
          let bullet = bullets[i];
          bullet.x += bullet.dx * 10 * elapsedTime;
          bullet.y += bullet.dy * 10 * elapsedTime;
          if (
            bullet.x < 0 || bullet.x >= mapWidth ||
            bullet.y < 0 || bullet.y >= mapHeight ||
            map[Math.floor(bullet.y)][Math.floor(bullet.x)] === '#'
          ) {
            bullets.splice(i, 1);
            continue;
          }
          for (let j = enemies.length - 1; j >= 0; j--) {
            const enemy = enemies[j];
            if (
              enemy.alive &&
              Math.floor(enemy.x) === Math.floor(bullet.x) &&
              Math.floor(enemy.y) === Math.floor(bullet.y)
            ) {
              showImpactAtEnemy(enemy);
              enemy.alive = false;
              bullets.splice(i, 1);
              break;
            }
          }
        }

        // Movimento e ataque dos inimigos
        for (let enemy of enemies) {
          if (!enemy.alive) continue;
          let dx = playerX - enemy.x;
          let dy = playerY - enemy.y;
          let dist = Math.sqrt(dx * dx + dy * dy);
          if (dist > 1.0) {
            const enemySpeed = 1.5;
            let newX = enemy.x + (dx / dist) * enemySpeed * elapsedTime;
            let newY = enemy.y + (dy / dist) * enemySpeed * elapsedTime;
            if (map[Math.floor(newY)][Math.floor(newX)] !== '#') {
              enemy.x = newX;
              enemy.y = newY;
            }
          } else {
            enemy.attackTimer -= elapsedTime;
            if (enemy.attackTimer <= 0) {
              playerHealth -= 10;
              enemy.attackTimer = 1.0;
            }
          }
        }

        if (playerHealth <= 0) {
          gameOver = true;
          const walkSound = document.getElementById("walkSound");
          walkSound.pause();
          walkSound.currentTime = 0;
        }
      }

      // Renderização 3D via Raycasting
      let screenColumns = new Array(screenWidth);
      for (let x = 0; x < screenWidth; x++) {
        const rayAngle = (playerA - FOV / 2.0) + (x / screenWidth) * FOV;
        let distanceToWall = 0;
        let hitWall = false;
        let boundary = false;
        const eyeX = Math.sin(rayAngle);
        const eyeY = Math.cos(rayAngle);
        while (!hitWall && distanceToWall < depth) {
          distanceToWall += 0.1;
          const testX = Math.floor(playerX + eyeX * distanceToWall);
          const testY = Math.floor(playerY + eyeY * distanceToWall);
          if (
            testX < 0 || testX >= mapWidth ||
            testY < 0 || testY >= mapHeight
          ) {
            hitWall = true;
            distanceToWall = depth;
          } else {
            if (map[testY][testX] === '#') {
              hitWall = true;
              const corners = [];
              for (let tx = 0; tx < 2; tx++) {
                for (let ty = 0; ty < 2; ty++) {
                  const vx = testX + tx - playerX;
                  const vy = testY + ty - playerY;
                  const d = Math.sqrt(vx * vx + vy * vy);
                  const dot = (eyeX * (vx / d)) + (eyeY * (vy / d));
                  corners.push({ distance: d, dot });
                }
              }
              corners.sort((a, b) => a.distance - b.distance);
              const bound = 0.01;
              if (Math.acos(corners[0].dot) < bound) boundary = true;
              if (Math.acos(corners[1].dot) < bound) boundary = true;
            }
          }
        }
        zBuffer[x] = distanceToWall;
        const ceiling = Math.floor((screenHeight / 2.0) - screenHeight / distanceToWall);
        const floor = screenHeight - ceiling;
        let column = "";
        for (let y = 0; y < screenHeight; y++) {
          if (y < ceiling) {
            column += " ";
          } else if (y >= ceiling && y <= floor) {
            let shade = " ";
            if (distanceToWall <= depth / 4.0)       shade = "\u2588";
            else if (distanceToWall < depth / 3.0)   shade = "\u2593";
            else if (distanceToWall < depth / 2.0)   shade = "\u2592";
            else if (distanceToWall < depth)         shade = "\u2591";
            else                                   shade = " ";
            if (boundary) shade = " ";
            column += shade;
          } else {
            const b = 1.0 - ((y - screenHeight / 2.0) / (screenHeight / 2.0));
            let floorShade = " ";
            if (b < 0.25) floorShade = "#";
            else if (b < 0.5) floorShade = "x";
            else if (b < 0.75) floorShade = ".";
            else if (b < 0.9) floorShade = "-";
            else floorShade = " ";
            column += floorShade;
          }
        }
        screenColumns[x] = column.split('');
      }

      // Renderiza inimigos
      enemies.forEach(enemy => {
        if (!enemy.alive) return;
        const dx = enemy.x - playerX;
        const dy = enemy.y - playerY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const enemyAngle = Math.atan2(dx, dy) - playerA;
        let enemyPos = (enemyAngle + FOV / 2.0) / FOV;
        if (enemyPos >= 0 && enemyPos < 1.0 && distance < depth) {
          const enemyHeight = Math.floor(screenHeight / distance);
          const enemyWidth = enemyHeight;
          const enemyColumn = Math.floor(enemyPos * screenWidth) - Math.floor(enemyWidth / 2);
          for (let x = 0; x < enemyWidth; x++) {
            const columnIndex = enemyColumn + x;
            if (columnIndex >= 0 && columnIndex < screenWidth) {
              if (distance < zBuffer[columnIndex]) {
                for (let y = 0; y < enemyHeight; y++) {
                  const row = Math.floor((screenHeight / 2) - enemyHeight / 2 + y);
                  if (row >= 0 && row < screenHeight) {
                    screenColumns[columnIndex][row] = "E";
                  }
                }
              }
            }
          }
        }
      });

      // Renderiza pickups
      renderPickups(screenColumns);

      // Renderiza balas
      bullets.forEach(bullet => {
        const dx = bullet.x - playerX;
        const dy = bullet.y - playerY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const bulletAngle = Math.atan2(dx, dy) - playerA;
        let bulletPos = (bulletAngle + FOV / 2.0) / FOV;
        if (bulletPos >= 0 && bulletPos < 1.0 && distance < depth) {
          const bulletColumn = Math.floor(bulletPos * screenWidth);
          const bulletRow = Math.floor(screenHeight / 2);
          if (distance < zBuffer[bulletColumn]) {
            screenColumns[bulletColumn][bulletRow] = "*";
          }
        }
      });

      // Combina as colunas para montar a tela final
      let finalScreen = "";
      for (let y = 0; y < screenHeight; y++) {
        for (let x = 0; x < screenWidth; x++) {
          finalScreen += screenColumns[x][y];
        }
        finalScreen += "\n";
      }
      document.getElementById("screen").innerText = finalScreen;

      // Atualiza o HUD
      const hudEl = document.getElementById("hud");
      hudEl.innerText = `Vida: ${playerHealth}    Munição: ${playerAmmo}    Arma: ${currentWeapon.toUpperCase()}`;
      if (gameOver) {
        hudEl.innerText += "\nGAME OVER – Pressione R para reiniciar";
      }

      requestAnimationFrame(gameLoop);
    }

    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
